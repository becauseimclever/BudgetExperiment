@* Calendar.razor - Month view calendar with daily transaction totals *@
@* Thin client - uses pre-computed data from API, no business logic *@

@page "/"
@page "/{Year:int}/{Month:int}"

@inject IBudgetApiService ApiService
@inject NavigationManager Navigation

<PageTitle>Budget Experiment</PageTitle>

<div class="page-container">
    <div class="split mb-4">
        <button class="btn btn-primary" @onclick="PreviousMonth">&lt; Previous</button>
        <h2 class="text-secondary m-0">@currentDate.ToString("MMMM yyyy")</h2>
        <button class="btn btn-primary" @onclick="NextMonth">Next &gt;</button>
    </div>

    <div class="account-filter">
        <label for="accountSelect">Filter by Account:</label>
        <select id="accountSelect" class="form-control" style="width: auto; display: inline-block; margin-left: var(--space-2);" @bind="selectedAccountId" @bind:after="LoadCalendarData">
            <option value="">All Accounts</option>
            @foreach (var account in accounts)
            {
                <option value="@account.Id">@account.Name</option>
            }
        </select>
    </div>

    <ErrorAlert Message="@errorMessage"
                IsDismissible="true"
                IsRetrying="@isRetrying"
                OnRetry="RetryLoad"
                OnDismiss="DismissError" />

    @if (isLoading)
    {
        <LoadingSpinner Message="Loading calendar..." />
    }
    else if (errorMessage == null && calendarGrid != null)
    {
        <CalendarGrid Days="@calendarGrid.Days"
                      SelectedDate="@selectedDate"
                      OnDaySelected="SelectDate" />
    }

    @if (selectedDate.HasValue && dayDetail != null)
    {
        <DayDetail Detail="@dayDetail"
                   OnAddTransaction="ShowAddTransaction"
                   OnEditInstance="ShowEditInstance"
                   OnSkipInstance="SkipInstance" />
    }

    <Modal IsVisible="@showAddTransaction" Title="Add Transaction" OnClose="HideAddTransaction">
        <TransactionForm
            Accounts="@accounts"
            ShowAccountSelector="true"
            InitialDate="@(selectedDate ?? DateOnly.FromDateTime(DateTime.Today))"
            IsSubmitting="@isSubmitting"
            OnSubmit="@CreateTransaction"
            OnCancel="@HideAddTransaction" />
    </Modal>

    <Modal IsVisible="@showEditInstance" Title="Edit This Occurrence" OnClose="HideEditInstance">
        @if (editingItem != null)
        {
            <EditInstanceDialog
                ScheduledDate="@dayDetail!.Date"
                OriginalDescription="@editingItem.Description"
                OriginalAmount="@editingItem.Amount.Amount"
                OriginalCurrency="@editingItem.Amount.Currency"
                AccountName="@editingItem.AccountName"
                IsSubmitting="@isSubmitting"
                OnSave="@ModifyInstance"
                OnCancel="@HideEditInstance" />
        }
    </Modal>

    <ConfirmDialog IsVisible="@showSkipConfirm"
                   Title="Skip This Occurrence"
                   Message="@($"Skip '{skippingItem?.Description}' on {dayDetail?.Date.ToString("MMMM d, yyyy")}? This won't affect other occurrences.")"
                   ConfirmText="Skip"
                   IsProcessing="@isSkipping"
                   OnConfirm="ConfirmSkipInstance"
                   OnCancel="CancelSkipInstance" />
</div>

@code {
    [Parameter]
    public int Year { get; set; }

    [Parameter]
    public int Month { get; set; }

    private DateOnly currentDate;
    private DateOnly? selectedDate;
    private string selectedAccountId = "";
    private Guid? filterAccountId => string.IsNullOrEmpty(selectedAccountId) ? null : Guid.Parse(selectedAccountId);

    // UI state
    private bool isLoading = true;
    private bool isRetrying;
    private string? errorMessage;

    // Data from API - no business logic, just display
    private List<AccountDto> accounts = new();
    private CalendarGridDto? calendarGrid;
    private DayDetailDto? dayDetail;

    // Modal state
    private bool showAddTransaction = false;
    private bool isSubmitting = false;

    // Instance editing state
    private bool showEditInstance = false;
    private DayDetailItemDto? editingItem;

    // Instance skipping state
    private bool showSkipConfirm = false;
    private bool isSkipping = false;
    private DayDetailItemDto? skippingItem;

    protected override async Task OnInitializedAsync()
    {
        if (Year == 0 || Month == 0)
        {
            var today = DateOnly.FromDateTime(DateTime.Today);
            Year = today.Year;
            Month = today.Month;
        }

        currentDate = new DateOnly(Year, Month, 1);
        await LoadAccounts();
        await LoadCalendarData();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (Year > 0 && Month > 0)
        {
            var newDate = new DateOnly(Year, Month, 1);
            if (newDate != currentDate)
            {
                currentDate = newDate;
                selectedDate = null;
                dayDetail = null;
                await LoadCalendarData();
            }
        }
    }

    private async Task LoadAccounts()
    {
        try
        {
            accounts = (await ApiService.GetAccountsAsync()).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load accounts: {ex.Message}";
        }
    }

    private async Task LoadCalendarData()
    {
        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            // Single API call returns complete pre-computed calendar grid
            calendarGrid = await ApiService.GetCalendarGridAsync(currentDate.Year, currentDate.Month, filterAccountId);
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load calendar data: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task RetryLoad()
    {
        isRetrying = true;
        StateHasChanged();

        try
        {
            await LoadAccounts();
            await LoadCalendarData();
        }
        finally
        {
            isRetrying = false;
        }
    }

    private void DismissError()
    {
        errorMessage = null;
    }

    private async Task SelectDate(DateOnly date)
    {
        selectedDate = date;
        // Single API call returns complete pre-merged day details
        dayDetail = await ApiService.GetDayDetailAsync(date, filterAccountId);
    }

    private void PreviousMonth()
    {
        var prev = currentDate.AddMonths(-1);
        Navigation.NavigateTo($"/{prev.Year}/{prev.Month}");
    }

    private void NextMonth()
    {
        var next = currentDate.AddMonths(1);
        Navigation.NavigateTo($"/{next.Year}/{next.Month}");
    }

    private void ShowAddTransaction()
    {
        showAddTransaction = true;
    }

    private void HideAddTransaction()
    {
        showAddTransaction = false;
    }

    private async Task CreateTransaction(TransactionCreateDto transaction)
    {
        isSubmitting = true;
        StateHasChanged();

        try
        {
            var result = await ApiService.CreateTransactionAsync(transaction);
            if (result != null)
            {
                showAddTransaction = false;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSubmitting = false;
        }
    }

    // Instance editing methods
    private void ShowEditInstance(DayDetailItemDto item)
    {
        editingItem = item;
        showEditInstance = true;
    }

    private void HideEditInstance()
    {
        showEditInstance = false;
        editingItem = null;
    }

    private async Task ModifyInstance(RecurringInstanceModifyDto model)
    {
        if (editingItem?.RecurringTransactionId == null || dayDetail == null)
        {
            return;
        }

        isSubmitting = true;
        StateHasChanged();

        try
        {
            var result = await ApiService.ModifyRecurringInstanceAsync(
                editingItem.RecurringTransactionId.Value,
                dayDetail.Date,
                model);

            if (result != null)
            {
                showEditInstance = false;
                editingItem = null;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSubmitting = false;
        }
    }

    // Instance skipping methods
    private void SkipInstance(DayDetailItemDto item)
    {
        skippingItem = item;
        showSkipConfirm = true;
    }

    private async Task ConfirmSkipInstance()
    {
        if (skippingItem?.RecurringTransactionId == null || dayDetail == null)
        {
            return;
        }

        isSkipping = true;
        StateHasChanged();

        try
        {
            var skipped = await ApiService.SkipRecurringInstanceAsync(
                skippingItem.RecurringTransactionId.Value,
                dayDetail.Date);

            if (skipped)
            {
                showSkipConfirm = false;
                skippingItem = null;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSkipping = false;
        }
    }

    private void CancelSkipInstance()
    {
        showSkipConfirm = false;
        skippingItem = null;
    }
}
