@* Calendar.razor - Month view calendar with daily transaction totals *@
@* Thin client - uses pre-computed data from API, no business logic *@

@page "/"
@page "/{Year:int}/{Month:int}"

@inject IBudgetApiService ApiService
@inject NavigationManager Navigation

<PageTitle>Budget Experiment</PageTitle>

<div class="page-container">
    <div class="split mb-4">
        <button class="btn btn-primary" @onclick="PreviousMonth">&lt; Previous</button>
        <h2 class="text-secondary m-0">@currentDate.ToString("MMMM yyyy")</h2>
        <button class="btn btn-primary" @onclick="NextMonth">Next &gt;</button>
    </div>

    <div class="account-filter">
        <label for="accountSelect">Filter by Account:</label>
        <select id="accountSelect" class="form-control" style="width: auto; display: inline-block; margin-left: var(--space-2);" @bind="selectedAccountId" @bind:after="LoadCalendarData">
            <option value="">All Accounts</option>
            @foreach (var account in accounts)
            {
                <option value="@account.Id">@account.Name</option>
            }
        </select>
    </div>

    <PastDueAlert PastDueSummary="@pastDueSummary" OnReviewClick="ShowPastDueReview" />

    <BudgetAlert BudgetSummary="@budgetSummary" OnViewBudgetClick="NavigateToBudget" />

    <ErrorAlert Message="@errorMessage"
                IsDismissible="true"
                IsRetrying="@isRetrying"
                OnRetry="RetryLoad"
                OnDismiss="DismissError" />

    @if (isLoading)
    {
        <LoadingSpinner Message="Loading calendar..." />
    }
    else if (errorMessage == null && calendarGrid != null)
    {
        <CalendarGrid Days="@calendarGrid.Days"
                      SelectedDate="@selectedDate"
                      OnDaySelected="SelectDate" />
    }

    @if (selectedDate.HasValue && dayDetail != null)
    {
        <DayDetail Detail="@dayDetail"
                   OnAddTransaction="ShowAddTransaction"
                   OnEditInstance="ShowEditInstance"
                   OnSkipInstance="SkipInstance"
                   OnConfirmInstance="ConfirmRecurringInstance" />
    }

    <Modal IsVisible="@showAddTransaction" Title="Add Transaction" OnClose="HideAddTransaction">
        <TransactionForm
            Accounts="@accounts"
            Categories="@categories"
            ShowAccountSelector="true"
            InitialDate="@(selectedDate ?? DateOnly.FromDateTime(DateTime.Today))"
            IsSubmitting="@isSubmitting"
            OnSubmit="@CreateTransaction"
            OnCancel="@HideAddTransaction" />
    </Modal>

    <Modal IsVisible="@showEditInstance" Title="Edit This Occurrence" OnClose="HideEditInstance">
        @if (editingItem != null)
        {
            <EditInstanceDialog
                ScheduledDate="@dayDetail!.Date"
                OriginalDescription="@editingItem.Description"
                OriginalAmount="@editingItem.Amount.Amount"
                OriginalCurrency="@editingItem.Amount.Currency"
                AccountName="@editingItem.AccountName"
                IsSubmitting="@isSubmitting"
                OnSave="@ModifyInstance"
                OnCancel="@HideEditInstance" />
        }
    </Modal>

    <ConfirmDialog IsVisible="@showSkipConfirm"
                   Title="Skip This Occurrence"
                   Message="@($"Skip '{skippingItem?.Description}' on {dayDetail?.Date.ToString("MMMM d, yyyy")}? This won't affect other occurrences.")"
                   ConfirmText="Skip"
                   IsProcessing="@isSkipping"
                   OnConfirm="ConfirmSkipInstance"
                   OnCancel="CancelSkipInstance" />

    <PastDueReviewModal IsVisible="@showPastDueReview"
                        Items="@pastDueSummary?.Items"
                        IsLoading="@isLoadingPastDue"
                        OnClose="HidePastDueReview"
                        OnConfirm="ConfirmPastDueItems"
                        OnSkip="SkipPastDueItems" />
</div>

@code {
    [Parameter]
    public int Year { get; set; }

    [Parameter]
    public int Month { get; set; }

    private DateOnly currentDate;
    private DateOnly? selectedDate;
    private string selectedAccountId = "";
    private Guid? filterAccountId => string.IsNullOrEmpty(selectedAccountId) ? null : Guid.Parse(selectedAccountId);

    // UI state
    private bool isLoading = true;
    private bool isRetrying;
    private string? errorMessage;

    // Data from API - no business logic, just display
    private List<AccountDto> accounts = new();
    private List<BudgetCategoryDto> categories = new();
    private CalendarGridDto? calendarGrid;
    private DayDetailDto? dayDetail;

    // Modal state
    private bool showAddTransaction = false;
    private bool isSubmitting = false;

    // Instance editing state
    private bool showEditInstance = false;
    private DayDetailItemDto? editingItem;

    // Instance skipping state
    private bool showSkipConfirm = false;
    private bool isSkipping = false;
    private DayDetailItemDto? skippingItem;

    // Instance confirmation (realization) state
#pragma warning disable CS0414 // Field is assigned but never used - will be used for loading state
    private bool isConfirming = false;
#pragma warning restore CS0414

    // Past-due state
    private PastDueSummaryDto? pastDueSummary;
    private bool showPastDueReview = false;
    private bool isLoadingPastDue = false;

    // Budget alert state
    private BudgetSummaryDto? budgetSummary;

    protected override async Task OnInitializedAsync()
    {
        if (Year == 0 || Month == 0)
        {
            var today = DateOnly.FromDateTime(DateTime.Today);
            Year = today.Year;
            Month = today.Month;
        }

        currentDate = new DateOnly(Year, Month, 1);
        await LoadAccounts();
        await LoadCategories();
        await LoadCalendarData();
        await LoadPastDueItems();
        await LoadBudgetSummary();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (Year > 0 && Month > 0)
        {
            var newDate = new DateOnly(Year, Month, 1);
            if (newDate != currentDate)
            {
                currentDate = newDate;
                selectedDate = null;
                dayDetail = null;
                await LoadCalendarData();
                await LoadBudgetSummary();
            }
        }
    }

    private async Task LoadAccounts()
    {
        try
        {
            accounts = (await ApiService.GetAccountsAsync()).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load accounts: {ex.Message}";
        }
    }

    private async Task LoadCategories()
    {
        try
        {
            categories = (await ApiService.GetCategoriesAsync()).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load categories: {ex.Message}";
        }
    }

    private async Task LoadBudgetSummary()
    {
        try
        {
            budgetSummary = await ApiService.GetBudgetSummaryAsync(currentDate.Year, currentDate.Month);
        }
        catch
        {
            // Budget summary loading is optional - don't show error for this
            budgetSummary = null;
        }
    }

    private async Task LoadCalendarData()
    {
        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            // Single API call returns complete pre-computed calendar grid
            calendarGrid = await ApiService.GetCalendarGridAsync(currentDate.Year, currentDate.Month, filterAccountId);
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load calendar data: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task RetryLoad()
    {
        isRetrying = true;
        StateHasChanged();

        try
        {
            await LoadAccounts();
            await LoadCalendarData();
        }
        finally
        {
            isRetrying = false;
        }
    }

    private void DismissError()
    {
        errorMessage = null;
    }

    private void NavigateToBudget()
    {
        Navigation.NavigateTo("/budget");
    }

    private async Task SelectDate(DateOnly date)
    {
        selectedDate = date;
        // Single API call returns complete pre-merged day details
        dayDetail = await ApiService.GetDayDetailAsync(date, filterAccountId);
    }

    private void PreviousMonth()
    {
        var prev = currentDate.AddMonths(-1);
        Navigation.NavigateTo($"/{prev.Year}/{prev.Month}");
    }

    private void NextMonth()
    {
        var next = currentDate.AddMonths(1);
        Navigation.NavigateTo($"/{next.Year}/{next.Month}");
    }

    private void ShowAddTransaction()
    {
        showAddTransaction = true;
    }

    private void HideAddTransaction()
    {
        showAddTransaction = false;
    }

    private async Task CreateTransaction(TransactionCreateDto transaction)
    {
        isSubmitting = true;
        StateHasChanged();

        try
        {
            var result = await ApiService.CreateTransactionAsync(transaction);
            if (result != null)
            {
                showAddTransaction = false;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSubmitting = false;
        }
    }

    // Instance editing methods
    private void ShowEditInstance(DayDetailItemDto item)
    {
        editingItem = item;
        showEditInstance = true;
    }

    private void HideEditInstance()
    {
        showEditInstance = false;
        editingItem = null;
    }

    private async Task ModifyInstance(RecurringInstanceModifyDto model)
    {
        if (editingItem?.RecurringTransactionId == null || dayDetail == null)
        {
            return;
        }

        isSubmitting = true;
        StateHasChanged();

        try
        {
            var result = await ApiService.ModifyRecurringInstanceAsync(
                editingItem.RecurringTransactionId.Value,
                dayDetail.Date,
                model);

            if (result != null)
            {
                showEditInstance = false;
                editingItem = null;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSubmitting = false;
        }
    }

    // Instance skipping methods
    private void SkipInstance(DayDetailItemDto item)
    {
        skippingItem = item;
        showSkipConfirm = true;
    }

    private async Task ConfirmSkipInstance()
    {
        if (skippingItem?.RecurringTransactionId == null || dayDetail == null)
        {
            return;
        }

        isSkipping = true;
        StateHasChanged();

        try
        {
            var skipped = await ApiService.SkipRecurringInstanceAsync(
                skippingItem.RecurringTransactionId.Value,
                dayDetail.Date);

            if (skipped)
            {
                showSkipConfirm = false;
                skippingItem = null;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSkipping = false;
        }
    }

    private void CancelSkipInstance()
    {
        showSkipConfirm = false;
        skippingItem = null;
    }

    // Instance confirmation (realization) methods
    private async Task ConfirmRecurringInstance(DayDetailItemDto item)
    {
        if (dayDetail == null)
        {
            return;
        }

        isConfirming = true;
        StateHasChanged();

        try
        {
            if (item.Type == "recurring" && item.RecurringTransactionId.HasValue)
            {
                // Realize recurring transaction
                var request = new RealizeRecurringTransactionRequest
                {
                    InstanceDate = dayDetail.Date,
                };
                var result = await ApiService.RealizeRecurringTransactionAsync(
                    item.RecurringTransactionId.Value,
                    request);

                if (result != null)
                {
                    await LoadCalendarData();
                    if (selectedDate.HasValue)
                    {
                        await SelectDate(selectedDate.Value);
                    }
                }
            }
            else if (item.Type == "recurring-transfer" && item.RecurringTransferId.HasValue)
            {
                // Realize recurring transfer
                var request = new RealizeRecurringTransferRequest
                {
                    InstanceDate = dayDetail.Date,
                };
                var result = await ApiService.RealizeRecurringTransferAsync(
                    item.RecurringTransferId.Value,
                    request);

                if (result != null)
                {
                    await LoadCalendarData();
                    if (selectedDate.HasValue)
                    {
                        await SelectDate(selectedDate.Value);
                    }
                }
            }
        }
        finally
        {
            isConfirming = false;
            StateHasChanged();
        }
    }

    // Past-due methods
    private async Task LoadPastDueItems()
    {
        try
        {
            pastDueSummary = await ApiService.GetPastDueItemsAsync(filterAccountId);
        }
        catch
        {
            // Silently fail - past due alert is not critical
            pastDueSummary = null;
        }
    }

    private void ShowPastDueReview()
    {
        showPastDueReview = true;
    }

    private void HidePastDueReview()
    {
        showPastDueReview = false;
    }

    private async Task ConfirmPastDueItems(IReadOnlyList<PastDueItemDto> items)
    {
        var request = new BatchRealizeRequest
        {
            Items = items.Select(i => new BatchRealizeItemRequest
            {
                Id = i.Id,
                Type = i.Type,
                InstanceDate = i.InstanceDate,
            }).ToList(),
        };

        var result = await ApiService.RealizeBatchAsync(request);
        if (result != null && result.SuccessCount > 0)
        {
            // Refresh data
            await LoadCalendarData();
            await LoadPastDueItems();
            if (selectedDate.HasValue)
            {
                await SelectDate(selectedDate.Value);
            }
        }

        if (result?.FailureCount > 0)
        {
            throw new Exception($"Failed to confirm {result.FailureCount} items.");
        }
    }

    private async Task SkipPastDueItems(IReadOnlyList<PastDueItemDto> items)
    {
        var failCount = 0;
        foreach (var item in items)
        {
            try
            {
                if (item.Type == "recurring-transaction")
                {
                    await ApiService.SkipRecurringInstanceAsync(item.Id, item.InstanceDate);
                }
                else if (item.Type == "recurring-transfer")
                {
                    await ApiService.SkipRecurringTransferInstanceAsync(item.Id, item.InstanceDate);
                }
            }
            catch
            {
                failCount++;
            }
        }

        // Refresh data
        await LoadCalendarData();
        await LoadPastDueItems();
        if (selectedDate.HasValue)
        {
            await SelectDate(selectedDate.Value);
        }

        if (failCount > 0)
        {
            throw new Exception($"Failed to skip {failCount} items.");
        }
    }
}
