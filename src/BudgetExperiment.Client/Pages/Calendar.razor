@* Calendar.razor - Month view calendar with daily transaction totals *@

@page "/"
@page "/{Year:int}/{Month:int}"

@using BudgetExperiment.Client.Models
@using BudgetExperiment.Client.Services
@using BudgetExperiment.Client.Components.Common

@inject IBudgetApiService ApiService
@inject NavigationManager Navigation

<PageTitle>Budget Experiment</PageTitle>

<div class="calendar-container">
    <div class="calendar-header">
        <button class="nav-button" @onclick="PreviousMonth">&lt; Previous</button>
        <h2>@currentDate.ToString("MMMM yyyy")</h2>
        <button class="nav-button" @onclick="NextMonth">Next &gt;</button>
    </div>

    <div class="account-filter">
        <label for="accountSelect">Filter by Account:</label>
        <select id="accountSelect" @bind="selectedAccountId" @bind:after="LoadCalendarData">
            <option value="">All Accounts</option>
            @foreach (var account in accounts)
            {
                <option value="@account.Id">@account.Name</option>
            }
        </select>
    </div>

    <ErrorAlert Message="@errorMessage"
                IsDismissible="true"
                IsRetrying="@isRetrying"
                OnRetry="RetryLoad"
                OnDismiss="DismissError" />

    @if (isLoading)
    {
        <LoadingSpinner Message="Loading calendar..." />
    }
    else if (errorMessage == null)
    {
        <CalendarGrid Days="@calendarDays"
                      SelectedDate="@selectedDate"
                      OnDaySelected="SelectDate" />
    }

    @if (selectedDate.HasValue)
    {
        <DayDetail SelectedDate="@selectedDate.Value"
                   Transactions="@selectedDayTransactions"
                   RecurringInstances="@selectedDayRecurring"
                   OnAddTransaction="ShowAddTransaction"
                   OnEditInstance="ShowEditInstance"
                   OnSkipInstance="SkipInstance" />
    }

    <Modal IsVisible="@showAddTransaction" Title="Add Transaction" OnClose="HideAddTransaction">
        <TransactionForm
            Accounts="@accounts"
            ShowAccountSelector="true"
            InitialDate="@(selectedDate ?? DateOnly.FromDateTime(DateTime.Today))"
            IsSubmitting="@isSubmitting"
            OnSubmit="@CreateTransaction"
            OnCancel="@HideAddTransaction" />
    </Modal>

    <Modal IsVisible="@showEditInstance" Title="Edit This Occurrence" OnClose="HideEditInstance">
        @if (editingInstance != null)
        {
            <EditInstanceDialog
                ScheduledDate="@editingInstance.ScheduledDate"
                OriginalDescription="@editingInstance.Description"
                OriginalAmount="@editingInstance.Amount.Amount"
                OriginalCurrency="@editingInstance.Amount.Currency"
                AccountName="@editingInstance.AccountName"
                IsSubmitting="@isSubmitting"
                OnSave="@ModifyInstance"
                OnCancel="@HideEditInstance" />
        }
    </Modal>

    <ConfirmDialog IsVisible="@showSkipConfirm"
                   Title="Skip This Occurrence"
                   Message="@($"Skip '{skippingInstance?.Description}' on {skippingInstance?.ScheduledDate.ToString("MMMM d, yyyy")}? This won't affect other occurrences.")"
                   ConfirmText="Skip"
                   IsProcessing="@isSkipping"
                   OnConfirm="ConfirmSkipInstance"
                   OnCancel="CancelSkipInstance" />
</div>

<style>
    .calendar-container {
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
    }

    .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .nav-button {
        padding: 8px 16px;
        cursor: pointer;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
    }

    .nav-button:hover {
        background: #0056b3;
    }

    .account-filter {
        margin-bottom: 20px;
    }

    .account-filter select {
        padding: 8px;
        margin-left: 10px;
    }
</style>

@code {
    [Parameter]
    public int Year { get; set; }

    [Parameter]
    public int Month { get; set; }

    private DateOnly currentDate;
    private DateOnly? selectedDate;
    private string selectedAccountId = "";
    private Guid? filterAccountId => string.IsNullOrEmpty(selectedAccountId) ? null : Guid.Parse(selectedAccountId);

    private bool isLoading = true;
    private bool isRetrying;
    private string? errorMessage;
    private List<AccountModel> accounts = new();
    private List<CalendarDayModel> calendarDays = new();
    private Dictionary<DateOnly, DailyTotalModel> dailyTotals = new();
    private Dictionary<DateOnly, List<RecurringInstanceModel>> recurringByDate = new();
    private List<TransactionModel> selectedDayTransactions = new();
    private List<RecurringInstanceModel> selectedDayRecurring = new();

    private bool showAddTransaction = false;
    private bool isSubmitting = false;

    // Instance editing state
    private bool showEditInstance = false;
    private RecurringInstanceModel? editingInstance;

    // Instance skipping state
    private bool showSkipConfirm = false;
    private bool isSkipping = false;
    private RecurringInstanceModel? skippingInstance;

    protected override async Task OnInitializedAsync()
    {
        if (Year == 0 || Month == 0)
        {
            var today = DateOnly.FromDateTime(DateTime.Today);
            Year = today.Year;
            Month = today.Month;
        }

        currentDate = new DateOnly(Year, Month, 1);
        await LoadAccounts();
        await LoadCalendarData();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (Year > 0 && Month > 0)
        {
            var newDate = new DateOnly(Year, Month, 1);
            if (newDate != currentDate)
            {
                currentDate = newDate;
                selectedDate = null;
                selectedDayTransactions.Clear();
                await LoadCalendarData();
            }
        }
    }

    private async Task LoadAccounts()
    {
        try
        {
            accounts = (await ApiService.GetAccountsAsync()).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load accounts: {ex.Message}";
        }
    }

    private async Task LoadCalendarData()
    {
        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            // Get the date range for the calendar grid (includes prev/next month days)
            var firstOfMonth = new DateOnly(currentDate.Year, currentDate.Month, 1);
            var startDayOfWeek = (int)firstOfMonth.DayOfWeek;
            var gridStartDate = firstOfMonth.AddDays(-startDayOfWeek);
            var gridEndDate = gridStartDate.AddDays(41); // 6 weeks

        // Fetch actual transaction totals
            var totals = await ApiService.GetCalendarSummaryAsync(currentDate.Year, currentDate.Month, filterAccountId);
            dailyTotals = totals.ToDictionary(t => t.Date, t => t);

            // Fetch projected recurring transactions for the visible range
            var projected = await ApiService.GetProjectedRecurringAsync(gridStartDate, gridEndDate, filterAccountId);
            recurringByDate = projected
                .GroupBy(p => p.ScheduledDate)
                .ToDictionary(g => g.Key, g => g.ToList());

            BuildCalendarDays();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load calendar data: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task RetryLoad()
    {
        isRetrying = true;
        StateHasChanged();

        try
        {
            await LoadAccounts();
            await LoadCalendarData();
        }
        finally
        {
            isRetrying = false;
        }
    }

    private void DismissError()
    {
        errorMessage = null;
    }

    private void BuildCalendarDays()
    {
        calendarDays.Clear();

        var firstOfMonth = new DateOnly(currentDate.Year, currentDate.Month, 1);
        var daysInMonth = DateTime.DaysInMonth(currentDate.Year, currentDate.Month);
        var startDayOfWeek = (int)firstOfMonth.DayOfWeek;
        var today = DateOnly.FromDateTime(DateTime.Today);

        // Add days from previous month
        var prevMonth = firstOfMonth.AddMonths(-1);
        var daysInPrevMonth = DateTime.DaysInMonth(prevMonth.Year, prevMonth.Month);
        for (int i = startDayOfWeek - 1; i >= 0; i--)
        {
            var date = new DateOnly(prevMonth.Year, prevMonth.Month, daysInPrevMonth - i);
            calendarDays.Add(new CalendarDayModel
            {
                Date = date,
                IsCurrentMonth = false,
                IsToday = date == today,
                DailyTotal = dailyTotals.GetValueOrDefault(date),
                RecurringInstances = recurringByDate.GetValueOrDefault(date) ?? new()
            });
        }

        // Add days from current month
        for (int day = 1; day <= daysInMonth; day++)
        {
            var date = new DateOnly(currentDate.Year, currentDate.Month, day);
            calendarDays.Add(new CalendarDayModel
            {
                Date = date,
                IsCurrentMonth = true,
                IsToday = date == today,
                DailyTotal = dailyTotals.GetValueOrDefault(date),
                RecurringInstances = recurringByDate.GetValueOrDefault(date) ?? new()
            });
        }

        // Add days from next month to complete the grid
        var nextMonth = firstOfMonth.AddMonths(1);
        var remainingDays = 42 - calendarDays.Count; // 6 rows x 7 days
        for (int day = 1; day <= remainingDays; day++)
        {
            var date = new DateOnly(nextMonth.Year, nextMonth.Month, day);
            calendarDays.Add(new CalendarDayModel
            {
                Date = date,
                IsCurrentMonth = false,
                IsToday = date == today,
                DailyTotal = dailyTotals.GetValueOrDefault(date),
                RecurringInstances = recurringByDate.GetValueOrDefault(date) ?? new()
            });
        }
    }

    private async Task SelectDate(DateOnly date)
    {
        selectedDate = date;
        selectedDayTransactions = (await ApiService.GetTransactionsAsync(date, date, filterAccountId)).ToList();
        selectedDayRecurring = recurringByDate.GetValueOrDefault(date) ?? new();
    }

    private void PreviousMonth()
    {
        var prev = currentDate.AddMonths(-1);
        Navigation.NavigateTo($"/{prev.Year}/{prev.Month}");
    }

    private void NextMonth()
    {
        var next = currentDate.AddMonths(1);
        Navigation.NavigateTo($"/{next.Year}/{next.Month}");
    }

    private void ShowAddTransaction()
    {
        showAddTransaction = true;
    }

    private void HideAddTransaction()
    {
        showAddTransaction = false;
    }

    private async Task CreateTransaction(TransactionCreateModel transaction)
    {
        isSubmitting = true;
        StateHasChanged();

        try
        {
            var result = await ApiService.CreateTransactionAsync(transaction);
            if (result != null)
            {
                showAddTransaction = false;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSubmitting = false;
        }
    }

    // Instance editing methods
    private void ShowEditInstance(RecurringInstanceModel instance)
    {
        editingInstance = instance;
        showEditInstance = true;
    }

    private void HideEditInstance()
    {
        showEditInstance = false;
        editingInstance = null;
    }

    private async Task ModifyInstance(RecurringInstanceModifyModel model)
    {
        if (editingInstance == null)
        {
            return;
        }

        isSubmitting = true;
        StateHasChanged();

        try
        {
            var result = await ApiService.ModifyRecurringInstanceAsync(
                editingInstance.RecurringTransactionId,
                editingInstance.ScheduledDate,
                model);

            if (result != null)
            {
                showEditInstance = false;
                editingInstance = null;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSubmitting = false;
        }
    }

    // Instance skipping methods
    private void SkipInstance(RecurringInstanceModel instance)
    {
        skippingInstance = instance;
        showSkipConfirm = true;
    }

    private async Task ConfirmSkipInstance()
    {
        if (skippingInstance == null)
        {
            return;
        }

        isSkipping = true;
        StateHasChanged();

        try
        {
            var skipped = await ApiService.SkipRecurringInstanceAsync(
                skippingInstance.RecurringTransactionId,
                skippingInstance.ScheduledDate);

            if (skipped)
            {
                showSkipConfirm = false;
                skippingInstance = null;
                await LoadCalendarData();
                if (selectedDate.HasValue)
                {
                    await SelectDate(selectedDate.Value);
                }
            }
        }
        finally
        {
            isSkipping = false;
        }
    }

    private void CancelSkipInstance()
    {
        showSkipConfirm = false;
        skippingInstance = null;
    }
}
