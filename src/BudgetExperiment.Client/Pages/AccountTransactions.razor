@* AccountTransactions.razor - Transaction management for a specific account *@
@* Thin client - uses pre-computed data from API, no business logic *@

@page "/accounts/{AccountId:guid}/transactions"

@using BudgetExperiment.Domain

@implements IDisposable

@inject IBudgetApiService ApiService
@inject NavigationManager Navigation
@inject ScopeService ScopeService

<PageTitle>@(accountName ?? "Account") Transactions - Budget Experiment</PageTitle>

<div class="page-container-wide">
    <PageHeader Title="@($"{accountName ?? "Loading..."} Transactions")"
                Subtitle="@transactionList?.AccountName"
                ShowBackButton="true"
                OnBack="GoBack">
        <Actions>
            <button class="btn btn-success" @onclick="ShowAddTransaction">+ Add Transaction</button>
        </Actions>
    </PageHeader>

    <ErrorAlert Message="@errorMessage"
                OnRetry="RetryLoad"
                OnDismiss="DismissError"
                IsRetrying="@isRetrying" />

    <PastDueAlert PastDueSummary="@pastDueSummary" OnReviewClick="ShowPastDueReview" />

    @if (transactionList != null && transactionList.InitialBalance.Amount != 0)
    {
        <div class="balance-banner">
            <div class="balance-display">
                <span class="balance-label">Starting Balance:</span>
                <span class="balance-amount @(transactionList.InitialBalance.Amount < 0 ? "negative" : "")">
                    @transactionList.InitialBalance.Amount.ToString("C")
                </span>
                <span class="balance-date">(as of @transactionList.InitialBalanceDate.ToString("MMM d, yyyy"))</span>
            </div>
            <div class="balance-display">
                <span class="balance-label">Current Balance:</span>
                <span class="balance-amount @(transactionList.Summary.CurrentBalance.Amount < 0 ? "negative" : "")">
                    @transactionList.Summary.CurrentBalance.Amount.ToString("C")
                </span>
            </div>
        </div>
    }

    <div class="filter-section">
        <div class="date-filter">
            <label>From:</label>
            <input type="date" @bind="startDate" @bind:after="LoadData" />
            <label>To:</label>
            <input type="date" @bind="endDate" @bind:after="LoadData" />
        </div>
        <div class="summary-stats">
            @if (transactionList != null)
            {
                <span class="summary-item">
                    Total: <MoneyDisplay Amount="@transactionList.Summary.TotalAmount.Amount" />
                </span>
                <span class="summary-item">Count: @transactionList.Items.Count</span>
                @if (transactionList.Summary.RecurringCount > 0)
                {
                    <span class="summary-item summary-item-recurring"><Icon Name="refresh" Size="14" /> @transactionList.Summary.RecurringCount recurring</span>
                }
            }
        </div>
    </div>

    @if (isLoading)
    {
        <LoadingSpinner Message="Loading transactions..." />
    }
    else if (transactionList != null)
    {
        <TransactionTable Items="@transactionListItems"
                          ShowDate="true"
                          ShowActions="true"
                          ShowBalance="true"
                          EmptyMessage="No transactions found for this period."
                          OnEditItem="EditTransaction"
                          OnDeleteItem="DeleteTransaction"
                          OnEditRecurring="ShowEditRecurringInstance"
                          OnSkipRecurring="ShowSkipRecurringInstance"
                          OnConfirmRecurring="ConfirmRecurringInstance" />
    }

    <Modal IsVisible="@showAddTransaction"
           Title="@(editingTransaction == null ? "Add Transaction" : "Edit Transaction")"
           OnClose="HideAddTransaction">
        <TransactionForm
            ShowAccountSelector="false"
            FixedAccountId="@AccountId"
            Categories="@categories"
            InitialDate="@(editingTransaction?.Date ?? DateOnly.FromDateTime(DateTime.Today))"
            InitialDescription="@(editingTransaction?.Description ?? "")"
            InitialAmount="@(editingTransaction?.Amount.Amount ?? 0)"
            InitialCategoryId="@editingTransaction?.CategoryId"
            IsSubmitting="@isSubmitting"
            ErrorMessage="@saveErrorMessage"
            OnSubmit="@SaveTransaction"
            OnCancel="@HideAddTransaction" />
    </Modal>

    <ConfirmDialog IsVisible="@showDeleteConfirm"
                   Title="Delete Transaction"
                   Message="@($"Are you sure you want to delete the transaction '{deletingItem?.Description}'?")"
                   ConfirmText="Delete"
                   IsProcessing="@isDeleting"
                   OnConfirm="ConfirmDelete"
                   OnCancel="CancelDelete" />

    @* Edit recurring instance dialog *@
    <Modal IsVisible="@showEditRecurring"
           Title="Edit Recurring Instance"
           OnClose="HideEditRecurring">
        @if (editingRecurringItem != null)
        {
            <EditInstanceDialog
                ScheduledDate="@editingRecurringItem.Date"
                OriginalDescription="@editingRecurringItem.Description"
                OriginalAmount="@editingRecurringItem.Amount.Amount"
                OriginalCurrency="@editingRecurringItem.Amount.Currency"
                IsSubmitting="@isSubmittingRecurring"
                OnSave="SaveRecurringInstance"
                OnCancel="HideEditRecurring" />
        }
    </Modal>

    @* Skip recurring instance confirmation *@
    <ConfirmDialog IsVisible="@showSkipRecurring"
                   Title="Skip Recurring Transaction"
                   Message="@($"Are you sure you want to skip this occurrence of '{skippingRecurringItem?.Description}' on {skippingRecurringItem?.Date.ToString("MMM d, yyyy")}?")"
                   ConfirmText="Skip"
                   IsProcessing="@isSkippingRecurring"
                   OnConfirm="ConfirmSkipRecurring"
                   OnCancel="CancelSkipRecurring" />

    <PastDueReviewModal IsVisible="@showPastDueReview"
                        Items="@pastDueSummary?.Items"
                        IsLoading="@isLoadingPastDue"
                        OnClose="HidePastDueReview"
                        OnConfirm="ConfirmPastDueItems"
                        OnSkip="SkipPastDueItems" />
</div>

@code {
    [Parameter]
    public Guid AccountId { get; set; }

    // Data from API - no business logic, just display
    private TransactionListDto? transactionList;
    private List<TransactionListItem> transactionListItems = new();
    private List<BudgetCategoryDto> categories = new();

    // UI state
    private bool isLoading = true;
    private bool isSubmitting = false;
    private bool showAddTransaction = false;
    private TransactionDto? editingTransaction = null;
    private DateTime startDate = DateTime.Today.AddMonths(-1);
    private DateTime endDate = DateTime.Today.AddMonths(1); // Include future for recurring

    // Account name for page title (fetched separately for title)
    private string? accountName;

    // Delete confirmation state
    private bool showDeleteConfirm = false;
    private bool isDeleting = false;
    private TransactionListItem? deletingItem = null;

    // Recurring instance state
    private bool showEditRecurring = false;
    private bool isSubmittingRecurring = false;
    private TransactionListItem? editingRecurringItem = null;
    private bool showSkipRecurring = false;
    private bool isSkippingRecurring = false;
    private TransactionListItem? skippingRecurringItem = null;
#pragma warning disable CS0414 // Field is assigned but never used (will be used for loading state)
    private bool isConfirmingRecurring = false;
#pragma warning restore CS0414

    // Error handling state
    private string? errorMessage;
    private bool isRetrying;
    private string? saveErrorMessage;

    // Past-due state
    private PastDueSummaryDto? pastDueSummary;
    private bool showPastDueReview = false;
    private bool isLoadingPastDue = false;

    private Guid previousAccountId;

    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        ScopeService.ScopeChanged += OnScopeChanged;
    }

    protected override async Task OnParametersSetAsync()
    {
        // Reload data when AccountId parameter changes (navigation between accounts)
        if (AccountId != previousAccountId)
        {
            previousAccountId = AccountId;
            await LoadData();
            await LoadCategories();
            await LoadPastDueItems();
        }
    }

    private async void OnScopeChanged(BudgetScope? _)
    {
        await InvokeAsync(async () =>
        {
            await LoadData();
            await LoadCategories();
            await LoadPastDueItems();
            StateHasChanged();
        });
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        ScopeService.ScopeChanged -= OnScopeChanged;
    }

    private async Task LoadCategories()
    {
        try
        {
            categories = (await ApiService.GetCategoriesAsync()).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load categories: {ex.Message}";
        }
    }

    private async Task LoadData()
    {
        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            var start = DateOnly.FromDateTime(startDate);
            var end = DateOnly.FromDateTime(endDate);

            // Single API call returns complete pre-merged transaction list
            transactionList = await ApiService.GetAccountTransactionListAsync(AccountId, start, end);
            accountName = transactionList.AccountName;

            // Convert to TransactionListItem for the table component
            transactionListItems = transactionList.Items.Select(ToTransactionListItem).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load transactions: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    /// <summary>
    /// Converts a TransactionListItemDto from API to the client's TransactionListItem for the table component.
    /// </summary>
    private static TransactionListItem ToTransactionListItem(TransactionListItemDto dto)
    {
        return new TransactionListItem
        {
            Id = dto.Id,
            Date = dto.Date,
            Description = dto.Description,
            CategoryId = dto.CategoryId,
            CategoryName = dto.CategoryName,
            Amount = dto.Amount,
            IsRecurring = dto.Type == "recurring" || dto.Type == "recurring-transfer",
            IsModified = dto.IsModified,
            CreatedAt = dto.CreatedAt,
            IsTransfer = dto.IsTransfer,
            TransferId = dto.TransferId,
            TransferDirection = dto.TransferDirection,
            IsRecurringTransfer = dto.Type == "recurring-transfer",
            RecurringTransferId = dto.RecurringTransferId,
            RunningBalance = dto.RunningBalance,
        };
    }

    private async Task RetryLoad()
    {
        isRetrying = true;
        StateHasChanged();

        try
        {
            await LoadData();
        }
        finally
        {
            isRetrying = false;
        }
    }

    private void DismissError()
    {
        errorMessage = null;
    }

    private void ShowAddTransaction()
    {
        editingTransaction = null;
        showAddTransaction = true;
    }

    private void EditTransaction(TransactionListItem item)
    {
        // Can only edit actual transactions, not recurring instances
        if (item.IsRecurring)
        {
            return;
        }

        // Create a minimal DTO for editing
        editingTransaction = new TransactionDto
        {
            Id = item.Id,
            Date = item.Date,
            Description = item.Description,
            Amount = item.Amount,
            CategoryId = item.CategoryId,
        };
        showAddTransaction = true;
    }

    private void HideAddTransaction()
    {
        showAddTransaction = false;
        editingTransaction = null;
        saveErrorMessage = null;
    }

    private async Task SaveTransaction(TransactionCreateDto transaction)
    {
        isSubmitting = true;
        saveErrorMessage = null;
        StateHasChanged();

        try
        {
            TransactionDto? result;

            if (editingTransaction != null)
            {
                // Update existing transaction
                var updateDto = new TransactionUpdateDto
                {
                    Amount = transaction.Amount,
                    Date = transaction.Date,
                    Description = transaction.Description,
                    CategoryId = transaction.CategoryId,
                };
                result = await ApiService.UpdateTransactionAsync(editingTransaction.Id, updateDto);
            }
            else
            {
                // Create new transaction
                result = await ApiService.CreateTransactionAsync(transaction);
            }

            if (result != null)
            {
                showAddTransaction = false;
                editingTransaction = null;
                await LoadData();
            }
        }
        catch (Exception ex)
        {
            saveErrorMessage = $"Failed to save transaction: {ex.Message}";
        }
        finally
        {
            isSubmitting = false;
        }
    }

    private async Task DeleteTransaction(Guid id)
    {
        deletingItem = transactionListItems.FirstOrDefault(t => t.Id == id);
        if (deletingItem != null)
        {
            showDeleteConfirm = true;
        }
    }

    private async Task ConfirmDelete()
    {
        if (deletingItem == null)
        {
            return;
        }

        isDeleting = true;
        StateHasChanged();

        try
        {
            // TODO: Implement delete when API supports it
            // await ApiService.DeleteTransactionAsync(deletingItem.Id);
            showDeleteConfirm = false;
            deletingItem = null;
            await LoadData();
        }
        finally
        {
            isDeleting = false;
        }
    }

    private void CancelDelete()
    {
        showDeleteConfirm = false;
        deletingItem = null;
    }

    // Recurring instance methods
    private void ShowEditRecurringInstance(TransactionListItem item)
    {
        editingRecurringItem = item;
        showEditRecurring = true;
    }

    private void HideEditRecurring()
    {
        showEditRecurring = false;
        editingRecurringItem = null;
    }

    private async Task SaveRecurringInstance(RecurringInstanceModifyDto model)
    {
        if (editingRecurringItem == null)
        {
            return;
        }

        isSubmittingRecurring = true;
        StateHasChanged();

        try
        {
            var result = await ApiService.ModifyRecurringInstanceAsync(
                editingRecurringItem.Id,
                editingRecurringItem.Date,
                model);

            if (result != null)
            {
                showEditRecurring = false;
                editingRecurringItem = null;
                await LoadData();
            }
        }
        finally
        {
            isSubmittingRecurring = false;
        }
    }

    private void ShowSkipRecurringInstance(TransactionListItem item)
    {
        skippingRecurringItem = item;
        showSkipRecurring = true;
    }

    private async Task ConfirmSkipRecurring()
    {
        if (skippingRecurringItem == null)
        {
            return;
        }

        isSkippingRecurring = true;
        StateHasChanged();

        try
        {
            var skipped = await ApiService.SkipRecurringInstanceAsync(
                skippingRecurringItem.Id,
                skippingRecurringItem.Date);

            if (skipped)
            {
                showSkipRecurring = false;
                skippingRecurringItem = null;
                await LoadData();
            }
        }
        finally
        {
            isSkippingRecurring = false;
        }
    }

    private void CancelSkipRecurring()
    {
        showSkipRecurring = false;
        skippingRecurringItem = null;
    }

    private async Task ConfirmRecurringInstance(TransactionListItem item)
    {
        isConfirmingRecurring = true;
        StateHasChanged();

        try
        {
            if (item.IsRecurringTransfer && item.RecurringTransferId.HasValue)
            {
                // Recurring transfer - realize both transactions
                var request = new RealizeRecurringTransferRequest
                {
                    InstanceDate = item.Date,
                };
                var result = await ApiService.RealizeRecurringTransferAsync(item.RecurringTransferId.Value, request);
                if (result != null)
                {
                    await LoadData();
                }
            }
            else
            {
                // Regular recurring transaction
                var request = new RealizeRecurringTransactionRequest
                {
                    InstanceDate = item.Date,
                };
                var result = await ApiService.RealizeRecurringTransactionAsync(item.Id, request);
                if (result != null)
                {
                    await LoadData();
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to confirm recurring instance: {ex.Message}";
        }
        finally
        {
            isConfirmingRecurring = false;
            StateHasChanged();
        }
    }

    private void GoBack()
    {
        Navigation.NavigateTo("/accounts");
    }

    // Past-due methods
    private async Task LoadPastDueItems()
    {
        try
        {
            pastDueSummary = await ApiService.GetPastDueItemsAsync(AccountId);
        }
        catch
        {
            // Silently fail - past due alert is not critical
            pastDueSummary = null;
        }
    }

    private void ShowPastDueReview()
    {
        showPastDueReview = true;
    }

    private void HidePastDueReview()
    {
        showPastDueReview = false;
    }

    private async Task ConfirmPastDueItems(IReadOnlyList<PastDueItemDto> items)
    {
        var request = new BatchRealizeRequest
        {
            Items = items.Select(i => new BatchRealizeItemRequest
            {
                Id = i.Id,
                Type = i.Type,
                InstanceDate = i.InstanceDate,
            }).ToList(),
        };

        var result = await ApiService.RealizeBatchAsync(request);
        if (result != null && result.SuccessCount > 0)
        {
            // Refresh data
            await LoadData();
            await LoadPastDueItems();
        }

        if (result?.FailureCount > 0)
        {
            throw new Exception($"Failed to confirm {result.FailureCount} items.");
        }
    }

    private async Task SkipPastDueItems(IReadOnlyList<PastDueItemDto> items)
    {
        var failCount = 0;
        foreach (var item in items)
        {
            try
            {
                if (item.Type == "recurring-transaction")
                {
                    await ApiService.SkipRecurringInstanceAsync(item.Id, item.InstanceDate);
                }
                else if (item.Type == "recurring-transfer")
                {
                    await ApiService.SkipRecurringTransferInstanceAsync(item.Id, item.InstanceDate);
                }
            }
            catch
            {
                failCount++;
            }
        }

        // Refresh data
        await LoadData();
        await LoadPastDueItems();

        if (failCount > 0)
        {
            throw new Exception($"Failed to skip {failCount} items.");
        }
    }
}
