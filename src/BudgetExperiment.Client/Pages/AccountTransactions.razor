@* AccountTransactions.razor - Transaction management for a specific account *@

@page "/accounts/{AccountId:guid}/transactions"

@using BudgetExperiment.Client.Models
@using BudgetExperiment.Client.Services
@using BudgetExperiment.Client.Components.Forms
@using BudgetExperiment.Client.Components.Common

@inject IBudgetApiService ApiService
@inject NavigationManager Navigation

<PageTitle>@(account?.Name ?? "Account") Transactions - Budget Experiment</PageTitle>

<div class="transactions-container">
    <PageHeader Title="@($"{account?.Name ?? "Loading..."} Transactions")"
                Subtitle="@account?.Type"
                ShowBackButton="true"
                OnBack="GoBack">
        <Actions>
            <button class="add-button" @onclick="ShowAddTransaction">+ Add Transaction</button>
        </Actions>
    </PageHeader>

    <ErrorAlert Message="@errorMessage"
                OnRetry="RetryLoad"
                OnDismiss="DismissError"
                IsRetrying="@isRetrying" />

    <div class="filter-section">
        <div class="date-filter">
            <label>From:</label>
            <input type="date" @bind="startDate" @bind:after="LoadData" />
            <label>To:</label>
            <input type="date" @bind="endDate" @bind:after="LoadData" />
        </div>
        <div class="summary">
            <span class="summary-item">
                Total: <MoneyDisplay Amount="@totalAmount" />
            </span>
            <span class="summary-item">Count: @allItems.Count</span>
            @if (recurringCount > 0)
            {
                <span class="summary-item recurring-count">ðŸ”„ @recurringCount recurring</span>
            }
        </div>
    </div>

    @if (isLoading)
    {
        <LoadingSpinner Message="Loading transactions..." />
    }
    else
    {
        <TransactionTable Items="@allItems"
                          ShowDate="true"
                          ShowActions="true"
                          EmptyMessage="No transactions found for this period."
                          OnEditItem="EditTransaction"
                          OnDeleteItem="DeleteTransaction"
                          OnEditRecurring="ShowEditRecurringInstance"
                          OnSkipRecurring="ShowSkipRecurringInstance" />
    }

    <Modal IsVisible="@showAddTransaction"
           Title="@(editingTransaction == null ? "Add Transaction" : "Edit Transaction")"
           OnClose="HideAddTransaction">
        <TransactionForm
            ShowAccountSelector="false"
            FixedAccountId="@AccountId"
            InitialDate="@(editingTransaction?.Date ?? DateOnly.FromDateTime(DateTime.Today))"
            InitialDescription="@(editingTransaction?.Description ?? "")"
            InitialAmount="@(editingTransaction?.Amount.Amount ?? 0)"
            InitialCategory="@editingTransaction?.Category"
            IsSubmitting="@isSubmitting"
            ErrorMessage="@saveErrorMessage"
            OnSubmit="@SaveTransaction"
            OnCancel="@HideAddTransaction" />
    </Modal>

    <ConfirmDialog IsVisible="@showDeleteConfirm"
                   Title="Delete Transaction"
                   Message="@($"Are you sure you want to delete the transaction '{deletingTransaction?.Description}'?")"
                   ConfirmText="Delete"
                   IsProcessing="@isDeleting"
                   OnConfirm="ConfirmDelete"
                   OnCancel="CancelDelete" />

    @* Edit recurring instance dialog *@
    <Modal IsVisible="@showEditRecurring"
           Title="Edit Recurring Instance"
           OnClose="HideEditRecurring">
        @if (editingRecurringItem != null)
        {
            <EditInstanceDialog
                ScheduledDate="@editingRecurringItem.Date"
                OriginalDescription="@editingRecurringItem.Description"
                OriginalAmount="@editingRecurringItem.Amount.Amount"
                OriginalCurrency="@editingRecurringItem.Amount.Currency"
                IsSubmitting="@isSubmittingRecurring"
                OnSave="SaveRecurringInstance"
                OnCancel="HideEditRecurring" />
        }
    </Modal>

    @* Skip recurring instance confirmation *@
    <ConfirmDialog IsVisible="@showSkipRecurring"
                   Title="Skip Recurring Transaction"
                   Message="@($"Are you sure you want to skip this occurrence of '{skippingRecurringItem?.Description}' on {skippingRecurringItem?.Date.ToString("MMM d, yyyy")}?")"
                   ConfirmText="Skip"
                   IsProcessing="@isSkippingRecurring"
                   OnConfirm="ConfirmSkipRecurring"
                   OnCancel="CancelSkipRecurring" />
</div>

<style>
    .transactions-container {
        max-width: 1000px;
        margin: 0 auto;
        padding: 20px;
    }

    .add-button {
        padding: 10px 20px;
        background: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    .add-button:hover {
        background: #218838;
    }

    .filter-section {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding: 15px;
        background: white;
        border-radius: 8px;
        border: 1px solid #dee2e6;
        flex-wrap: wrap;
        gap: 15px;
    }

    .date-filter {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .date-filter input {
        padding: 6px 10px;
        border: 1px solid #ced4da;
        border-radius: 4px;
    }

    .summary {
        display: flex;
        gap: 20px;
    }

    .summary-item {
        font-weight: 500;
    }

    .recurring-count {
        color: #007bff;
    }
</style>

@code {
    [Parameter]
    public Guid AccountId { get; set; }

    private AccountModel? account;
    private List<TransactionModel> transactions = new();
    private List<RecurringInstanceModel> recurringInstances = new();
    private List<TransactionListItem> allItems = new();
    private bool isLoading = true;
    private bool isSubmitting = false;
    private bool showAddTransaction = false;
    private TransactionModel? editingTransaction = null;
    private DateTime startDate = DateTime.Today.AddMonths(-1);
    private DateTime endDate = DateTime.Today.AddMonths(1); // Include future for recurring

    // Delete confirmation state
    private bool showDeleteConfirm = false;
    private bool isDeleting = false;
    private TransactionModel? deletingTransaction = null;

    // Recurring instance state
    private bool showEditRecurring = false;
    private bool isSubmittingRecurring = false;
    private TransactionListItem? editingRecurringItem = null;
    private bool showSkipRecurring = false;
    private bool isSkippingRecurring = false;
    private TransactionListItem? skippingRecurringItem = null;

    // Error handling state
    private string? errorMessage;
    private bool isRetrying;
    private string? saveErrorMessage;

    private decimal totalAmount => allItems.Sum(i => i.Amount.Amount);
    private int recurringCount => allItems.Count(i => i.IsRecurring);

    private Guid previousAccountId;

    protected override async Task OnParametersSetAsync()
    {
        // Reload data when AccountId parameter changes (navigation between accounts)
        if (AccountId != previousAccountId)
        {
            previousAccountId = AccountId;
            await LoadAccount();
            await LoadData();
        }
    }

    private async Task LoadAccount()
    {
        try
        {
            account = await ApiService.GetAccountAsync(AccountId);
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load account: {ex.Message}";
        }
    }

    private async Task LoadData()
    {
        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            var start = DateOnly.FromDateTime(startDate);
            var end = DateOnly.FromDateTime(endDate);

            // Load transactions and recurring instances in parallel
            var transactionsTask = ApiService.GetTransactionsAsync(start, end, AccountId);
            var recurringTask = ApiService.GetProjectedRecurringAsync(start, end, AccountId);

            await Task.WhenAll(transactionsTask, recurringTask);

            transactions = transactionsTask.Result.ToList();
            recurringInstances = recurringTask.Result.Where(r => !r.IsSkipped).ToList();

            // Merge into unified list
            MergeTransactionsAndRecurring();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load transactions: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task RetryLoad()
    {
        isRetrying = true;
        StateHasChanged();

        try
        {
            await LoadAccount();
            await LoadData();
        }
        finally
        {
            isRetrying = false;
        }
    }

    private void DismissError()
    {
        errorMessage = null;
    }

    private void MergeTransactionsAndRecurring()
    {
        allItems.Clear();

        // Add actual transactions
        foreach (var txn in transactions)
        {
            allItems.Add(TransactionListItem.FromTransaction(txn));
        }

        // Add recurring instances (only those that don't already have a realized transaction)
        foreach (var instance in recurringInstances)
        {
            // Check if there's already a transaction on this date with same description
            // This is a simple heuristic - could be enhanced with linking logic
            var hasRealized = transactions.Any(t =>
                t.Date == instance.ScheduledDate &&
                t.Description == instance.Description);

            if (!hasRealized)
            {
                allItems.Add(TransactionListItem.FromRecurringInstance(instance));
            }
        }
    }

    private void ShowAddTransaction()
    {
        editingTransaction = null;
        showAddTransaction = true;
    }

    private void EditTransaction(TransactionListItem item)
    {
        // Find the original transaction
        editingTransaction = transactions.FirstOrDefault(t => t.Id == item.Id);
        if (editingTransaction != null)
        {
            showAddTransaction = true;
        }
    }

    private void HideAddTransaction()
    {
        showAddTransaction = false;
        editingTransaction = null;
        saveErrorMessage = null;
    }

    private async Task SaveTransaction(TransactionCreateModel transaction)
    {
        isSubmitting = true;
        saveErrorMessage = null;
        StateHasChanged();

        try
        {
            // TODO: Support updating transactions when API supports it
            var result = await ApiService.CreateTransactionAsync(transaction);
            if (result != null)
            {
                showAddTransaction = false;
                editingTransaction = null;
                await LoadData();
            }
        }
        catch (Exception ex)
        {
            saveErrorMessage = $"Failed to save transaction: {ex.Message}";
        }
        finally
        {
            isSubmitting = false;
        }
    }

    private async Task DeleteTransaction(Guid id)
    {
        deletingTransaction = transactions.FirstOrDefault(t => t.Id == id);
        if (deletingTransaction != null)
        {
            showDeleteConfirm = true;
        }
    }

    private async Task ConfirmDelete()
    {
        if (deletingTransaction == null)
        {
            return;
        }

        isDeleting = true;
        StateHasChanged();

        try
        {
            // TODO: Implement delete when API supports it
            // await ApiService.DeleteTransactionAsync(deletingTransaction.Id);
            showDeleteConfirm = false;
            deletingTransaction = null;
            await LoadData();
        }
        finally
        {
            isDeleting = false;
        }
    }

    private void CancelDelete()
    {
        showDeleteConfirm = false;
        deletingTransaction = null;
    }

    // Recurring instance methods
    private void ShowEditRecurringInstance(TransactionListItem item)
    {
        editingRecurringItem = item;
        showEditRecurring = true;
    }

    private void HideEditRecurring()
    {
        showEditRecurring = false;
        editingRecurringItem = null;
    }

    private async Task SaveRecurringInstance(RecurringInstanceModifyModel model)
    {
        if (editingRecurringItem == null)
        {
            return;
        }

        isSubmittingRecurring = true;
        StateHasChanged();

        try
        {
            var result = await ApiService.ModifyRecurringInstanceAsync(
                editingRecurringItem.Id,
                editingRecurringItem.Date,
                model);

            if (result != null)
            {
                showEditRecurring = false;
                editingRecurringItem = null;
                await LoadData();
            }
        }
        finally
        {
            isSubmittingRecurring = false;
        }
    }

    private void ShowSkipRecurringInstance(TransactionListItem item)
    {
        skippingRecurringItem = item;
        showSkipRecurring = true;
    }

    private async Task ConfirmSkipRecurring()
    {
        if (skippingRecurringItem == null)
        {
            return;
        }

        isSkippingRecurring = true;
        StateHasChanged();

        try
        {
            var skipped = await ApiService.SkipRecurringInstanceAsync(
                skippingRecurringItem.Id,
                skippingRecurringItem.Date);

            if (skipped)
            {
                showSkipRecurring = false;
                skippingRecurringItem = null;
                await LoadData();
            }
        }
        finally
        {
            isSkippingRecurring = false;
        }
    }

    private void CancelSkipRecurring()
    {
        showSkipRecurring = false;
        skippingRecurringItem = null;
    }

    private void GoBack()
    {
        Navigation.NavigateTo("/accounts");
    }
}
