@page "/accounts"

@using BudgetExperiment.Domain

@implements IDisposable

@inject IBudgetApiService ApiService
@inject NavigationManager Navigation
@inject ScopeService ScopeService

<PageTitle>Accounts - Budget Experiment</PageTitle>

<div class="page-container">
    <PageHeader Title="Accounts">
        <Actions>
            <Button Variant="ButtonVariant.Primary" IconLeft="arrows-horizontal" OnClick="ShowTransfer">Transfer</Button>
            <Button Variant="ButtonVariant.Success" OnClick="ShowAddAccount">+ Add Account</Button>
        </Actions>
    </PageHeader>

    <ErrorAlert Message="@errorMessage"
                OnRetry="RetryLoad"
                OnDismiss="DismissError"
                IsRetrying="@isRetrying" />

    @if (isLoading)
    {
        <LoadingSpinner Message="Loading accounts..." />
    }
    else if (accounts.Count == 0 && errorMessage == null)
    {
        <p class="empty-message">No accounts yet. Create one to get started!</p>
    }
    else if (errorMessage == null)
    {
        <div class="card-grid">
            @foreach (var account in accounts)
            {
                <div class="card">
                    <div class="card-body">
                        <div class="d-flex align-items-center gap-2">
                            <h3 class="card-title">@account.Name</h3>
                            <ScopeBadge Scope="@account.Scope" ShowLabel="false" />
                        </div>
                        <span class="text-secondary text-sm">@account.Type</span>
                        <div class="mt-3 text-sm">
                            <span class="text-secondary">Initial Balance:</span>
                            <span class="font-semibold ml-1 @(account.InitialBalance < 0 ? "text-expense" : "")">
                                @(account.InitialBalance.ToString("C"))
                            </span>
                            <span class="text-disabled text-xs ml-1">(as of @account.InitialBalanceDate.ToString("M/d/yyyy"))</span>
                        </div>
                    </div>
                    <div class="card-footer d-flex gap-2">
                        <Button Variant="ButtonVariant.Secondary" Size="ButtonSize.Small" IconLeft="edit" OnClick="() => ShowEditAccount(account)" title="Edit account" />
                        <Button Variant="ButtonVariant.Primary" Size="ButtonSize.Small" IconLeft="arrows-horizontal" OnClick="() => ShowTransferFrom(account.Id)" title="Transfer from this account" />
                        <Button Variant="ButtonVariant.Primary" Size="ButtonSize.Small" OnClick="() => ViewAccount(account.Id)">Transactions</Button>
                        <Button Variant="ButtonVariant.Danger" Size="ButtonSize.Small" OnClick="() => DeleteAccount(account.Id)">Delete</Button>
                    </div>
                </div>
            }
        </div>
    }

    <Modal IsVisible="@showAddAccount" Title="Add Account" OnClose="HideAddAccount">
        <AccountForm Model="@newAccount"
                     OnSubmit="CreateAccount"
                     OnCancel="HideAddAccount"
                     IsSubmitting="@isSubmitting" />
    </Modal>

    <Modal IsVisible="@showEditAccount" Title="Edit Account" OnClose="HideEditAccount">
        <AccountForm Model="@editAccount"
                     OnSubmit="UpdateAccount"
                     OnCancel="HideEditAccount"
                     SubmitButtonText="Save Changes"
                     IsSubmitting="@isSubmitting" />
        <div class="alert alert-warning mt-4">
            <Icon Name="alert-triangle" Size="16" /> Changing initial balance will affect all calculated running balances.
        </div>
    </Modal>

    <Modal IsVisible="@showTransfer" Title="Transfer Between Accounts" OnClose="HideTransfer">
        <TransferDialog Accounts="@accounts"
                        Model="@newTransfer"
                        PreSelectedSourceAccountId="@preSelectedSourceAccountId"
                        OnCreate="CreateTransfer"
                        OnCancel="HideTransfer" />
    </Modal>

    <ConfirmDialog IsVisible="@showDeleteConfirm"
                   Title="Delete Account"
                   Message="@($"Are you sure you want to delete '{deletingAccount?.Name}'? This will also delete all transactions for this account.")"
                   ConfirmText="Delete"
                   IsProcessing="@isDeleting"
                   OnConfirm="ConfirmDelete"
                   OnCancel="CancelDelete" />
</div>

@code {
    private bool isLoading = true;
    private bool isRetrying;
    private bool isSubmitting = false;
    private string? errorMessage;
    private List<AccountDto> accounts = new();
    private bool showAddAccount = false;
    private AccountCreateDto newAccount = new();

    // Edit state
    private bool showEditAccount = false;
    private AccountCreateDto editAccount = new();
    private Guid? editingAccountId = null;

    // Transfer state
    private bool showTransfer = false;
    private CreateTransferRequest newTransfer = new();
    private Guid? preSelectedSourceAccountId = null;

    // Delete confirmation state
    private bool showDeleteConfirm = false;
    private bool isDeleting = false;
    private AccountDto? deletingAccount = null;

    protected override async Task OnInitializedAsync()
    {
        ScopeService.ScopeChanged += OnScopeChanged;
        await LoadAccounts();
    }

    private async void OnScopeChanged(BudgetScope? _)
    {
        await InvokeAsync(async () =>
        {
            await LoadAccounts();
            StateHasChanged();
        });
    }

    public void Dispose()
    {
        ScopeService.ScopeChanged -= OnScopeChanged;
    }

    private async Task LoadAccounts()
    {
        isLoading = true;
        errorMessage = null;

        try
        {
            accounts = (await ApiService.GetAccountsAsync()).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load accounts: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task RetryLoad()
    {
        isRetrying = true;
        StateHasChanged();

        try
        {
            await LoadAccounts();
        }
        finally
        {
            isRetrying = false;
        }
    }

    private void DismissError()
    {
        errorMessage = null;
    }

    private void ShowAddAccount()
    {
        newAccount = new AccountCreateDto { Type = "Checking" };
        showAddAccount = true;
    }

    private void HideAddAccount()
    {
        showAddAccount = false;
    }

    private void ShowEditAccount(AccountDto account)
    {
        editingAccountId = account.Id;
        editAccount = new AccountCreateDto
        {
            Name = account.Name,
            Type = account.Type,
            InitialBalance = account.InitialBalance,
            InitialBalanceCurrency = account.InitialBalanceCurrency,
            InitialBalanceDate = account.InitialBalanceDate,
        };
        showEditAccount = true;
    }

    private void HideEditAccount()
    {
        showEditAccount = false;
        editingAccountId = null;
    }

    private async Task UpdateAccount(AccountCreateDto model)
    {
        if (editingAccountId == null)
        {
            return;
        }

        isSubmitting = true;
        try
        {
            var updateDto = new AccountUpdateDto
            {
                Name = model.Name,
                Type = model.Type,
                InitialBalance = model.InitialBalance,
                InitialBalanceCurrency = model.InitialBalanceCurrency,
                InitialBalanceDate = model.InitialBalanceDate,
            };

            var result = await ApiService.UpdateAccountAsync(editingAccountId.Value, updateDto);
            if (result != null)
            {
                showEditAccount = false;
                editingAccountId = null;
                await LoadAccounts();
            }
        }
        finally
        {
            isSubmitting = false;
        }
    }

    private void ShowTransfer()
    {
        preSelectedSourceAccountId = null;
        newTransfer = new CreateTransferRequest();
        showTransfer = true;
    }

    private void ShowTransferFrom(Guid accountId)
    {
        preSelectedSourceAccountId = accountId;
        newTransfer = new CreateTransferRequest { SourceAccountId = accountId };
        showTransfer = true;
    }

    private void HideTransfer()
    {
        showTransfer = false;
        preSelectedSourceAccountId = null;
    }

    private async Task CreateTransfer(CreateTransferRequest model)
    {
        var result = await ApiService.CreateTransferAsync(model);
        if (result != null)
        {
            showTransfer = false;
            // Optionally navigate to the transaction view or show a success message
        }
    }

    private async Task CreateAccount(AccountCreateDto model)
    {
        isSubmitting = true;
        try
        {
            var result = await ApiService.CreateAccountAsync(model);
            if (result != null)
            {
                showAddAccount = false;
                await LoadAccounts();
            }
        }
        finally
        {
            isSubmitting = false;
        }
    }

    private void ViewAccount(Guid id)
    {
        Navigation.NavigateTo($"/accounts/{id}/transactions");
    }

    private void DeleteAccount(Guid id)
    {
        deletingAccount = accounts.FirstOrDefault(a => a.Id == id);
        if (deletingAccount != null)
        {
            showDeleteConfirm = true;
        }
    }

    private async Task ConfirmDelete()
    {
        if (deletingAccount == null)
        {
            return;
        }

        isDeleting = true;
        StateHasChanged();

        try
        {
            var deleted = await ApiService.DeleteAccountAsync(deletingAccount.Id);
            if (deleted)
            {
                showDeleteConfirm = false;
                deletingAccount = null;
                await LoadAccounts();
            }
        }
        finally
        {
            isDeleting = false;
        }
    }

    private void CancelDelete()
    {
        showDeleteConfirm = false;
        deletingAccount = null;
    }
}
